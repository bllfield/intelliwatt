generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum RateType {
  FIXED
  VARIABLE
  TIME_OF_USE
  OTHER
}

model User {
  id                 String                  @id @default(cuid())
  email              String                  @unique
  createdAt          DateTime                @default(now())
  referredById       String?
  commissions        CommissionRecord[]
  testimonials       TestimonialSubmission[]
  entries            Entry[]                 @relation("UserEntries")
  jackpotPayouts     JackpotPayout[]
  referrals          Referral[]              @relation("UserReferrals")
  incomingReferrals  Referral[]              @relation("UserReferralInvitee")
  sessions           Session[]
  usage              UsageData[]
  profile            UserProfile?
  utilityPlans       UtilityPlan[]
  smtAuthorizations  SmtAuthorization[]
  manualUsageUploads ManualUsageUpload[]
  entryExpiryDigests EntryExpiryDigest[]     @relation("EntryExpiryDigestUser")
}

model UserProfile {
  id                      String          @id @default(cuid())
  userId                  String          @unique
  fullName                String?
  phone                   String?
  address                 String?
  zipCode                 String?
  homeSqFt                Int?
  homeAge                 Int?
  numStories              Int?
  numBedrooms             Int?
  numBathrooms            Int?
  wallMaterial            String?
  foundationType          String?
  insulationType          String?
  windowType              String?
  windowSealing           String?
  roofDirection           String?
  ledLighting             Boolean?
  smartThermostat         Boolean?
  thermostatType          String?
  summerTemp              Int?
  winterTemp              Int?
  heatingType             String?
  hvacType                String?
  waterHeaterType         String?
  pool                    Boolean?
  poolPumpType            String?
  evChargerType           String?
  evMilesPerDay           Int?
  numOccupants            Int?
  numStayHome             Int?
  numWorkOrSchool         Int?
  numFridges              Int?
  lightingType            String?
  applianceImagesUploaded Boolean?
  unusualTravelDates      String?
  hasSolar                Boolean?
  hasBattery              Boolean?
  plansToAddSolar         Boolean?
  plansToAddBattery       Boolean?
  createdAt               DateTime        @default(now())
  addressCity             String?
  addressLine1            String?
  addressState            String?
  addressValidated        Boolean?
  addressZip              String?
  esiid                   String?
  smartMeterConsent       Boolean?
  smartMeterConsentDate   DateTime?
  tdspSlug                String?
  esiidAttentionRequired  Boolean         @default(false)
  esiidAttentionCode      String?
  esiidAttentionAt        DateTime?
  apiConnections          ApiConnection[]
  appliances              Appliance[]
  solarSystem             SolarSystem?
  user                    User            @relation(fields: [userId], references: [id])
}

model Appliance {
  id         String      @id @default(cuid())
  profileId  String
  type       String
  brand      String?
  model      String?
  year       Int?
  energyStar Boolean?
  dailyKWh   Float?
  photoUrl   String?
  vin        String?
  schedule   String?
  createdAt  DateTime    @default(now())
  profile    UserProfile @relation(fields: [profileId], references: [id])
}

model ApiConnection {
  id          String      @id @default(cuid())
  profileId   String
  provider    String
  isActive    Boolean
  connectedAt DateTime    @default(now())
  profile     UserProfile @relation(fields: [profileId], references: [id])
}

model SolarSystem {
  id              String      @id @default(cuid())
  profileId       String      @unique
  numPanels       Int?
  panelModel      String?
  panelWattage    Int?
  annualKWh       Float?
  azimuth         Int?
  tilt            Int?
  batteryModel    String?
  batteryCount    Int?
  batteryCapacity Float?
  exportRate      Float?
  netMetering     Boolean?
  createdAt       DateTime    @default(now())
  profile         UserProfile @relation(fields: [profileId], references: [id])
}

model UsageData {
  id        String   @id @default(cuid())
  userId    String
  source    String
  interval  String
  data      Json
  startDate DateTime
  endDate   DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model UtilityPlan {
  id          String    @id @default(cuid())
  userId      String
  provider    String
  planName    String
  rateImport  Float
  rateExport  Float
  deliveryFee Float
  monthlyFee  Float
  expiration  DateTime?
  isCurrent   Boolean
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id])
}

model Referral {
  id             String         @id @default(cuid())
  referredById   String
  referredEmail  String
  referredUserId String?
  status         ReferralStatus @default(PENDING)
  qualifiedAt    DateTime?
  entryAwardedAt DateTime?
  createdAt      DateTime       @default(now())
  referredBy     User           @relation("UserReferrals", fields: [referredById], references: [id])
  referredUser   User?          @relation("UserReferralInvitee", fields: [referredUserId], references: [id])
  entry          Entry?         @relation("ReferralEntry")

  @@index([referredById])
  @@index([referredEmail])
  @@index([referredUserId])
  @@index([status])
}

model Entry {
  id               String             @id @default(cuid())
  userId           String
  type             String
  amount           Int
  createdAt        DateTime           @default(now())
  user             User               @relation("UserEntries", fields: [userId], references: [id])
  houseId          String?
  house            HouseAddress?      @relation(fields: [houseId], references: [id])
  referralId       String?            @unique
  referral         Referral?          @relation("ReferralEntry", fields: [referralId], references: [id])
  status           EntryStatus        @default(ACTIVE)
  expiresAt        DateTime?
  lastValidated    DateTime?
  expirationReason String?
  manualUsageId    String?
  manualUsage      ManualUsageUpload? @relation("EntryManualUsage", fields: [manualUsageId], references: [id])
  statusLogs       EntryStatusLog[]
  expiryDigest     EntryExpiryDigest? @relation("EntryExpiryDigestEntry")

  @@unique([manualUsageId])
  @@index([houseId])
  @@index([expiresAt])
  @@index([status])
  @@index([referralId])
}

model EntryStatusLog {
  id        String       @id @default(cuid())
  entryId   String
  previous  EntryStatus?
  next      EntryStatus
  reason    String?
  createdAt DateTime     @default(now())
  entry     Entry        @relation(fields: [entryId], references: [id])

  @@index([entryId])
  @@index([createdAt])
}

model ManualUsageUpload {
  id         String        @id @default(cuid())
  userId     String
  houseId    String?
  source     String        @default("manual")
  uploadedAt DateTime      @default(now())
  expiresAt  DateTime
  metadata   Json?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt
  user       User          @relation(fields: [userId], references: [id])
  house      HouseAddress? @relation(fields: [houseId], references: [id])
  entry      Entry?        @relation("EntryManualUsage")

  @@index([userId])
  @@index([houseId])
  @@index([expiresAt])
}

model NormalizedCurrentPlan {
  id                  String    @id @default(cuid())
  userId              String?
  homeId              String?
  providerName        String
  planName            String
  rateType            RateType
  rateStructure       Json
  flatEnergyRateCents Decimal?  @db.Decimal(8, 4)
  baseMonthlyFeeCents Decimal?  @db.Decimal(10, 2)
  termLengthMonths    Int?
  contractEndDate     DateTime?
  sourceModule        String    @default("current-plan")
  sourceEntryId       String
  sourceUpdatedAt     DateTime?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  @@unique([sourceModule, sourceEntryId])
  @@index([userId])
  @@index([homeId])
}

model EntryExpiryDigest {
  entryId    String      @id
  userId     String
  entryType  String
  status     EntryStatus
  expiresAt  DateTime?
  recordedAt DateTime    @default(now())
  entry      Entry       @relation("EntryExpiryDigestEntry", fields: [entryId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  user       User        @relation("EntryExpiryDigestUser", fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@index([userId])
  @@index([status])
  @@index([recordedAt])
}

enum EntryStatus {
  ACTIVE
  EXPIRING_SOON
  EXPIRED
}

enum ReferralStatus {
  PENDING
  QUALIFIED
  CANCELLED
}

enum TestimonialStatus {
  PENDING
  APPROVED
  REJECTED
}

enum SmtEmailConfirmationStatus {
  PENDING
  APPROVED
  DECLINED
}

model TestimonialSubmission {
  id             String            @id @default(cuid())
  userId         String
  content        String
  status         TestimonialStatus @default(PENDING)
  submittedAt    DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  publishedAt    DateTime?
  entryAwardedAt DateTime?
  source         String?
  user           User              @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([userId])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  token     String   @unique
  expiresAt DateTime
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model MagicLinkToken {
  id            String   @id @default(cuid())
  email         String
  token         String   @unique
  expiresAt     DateTime
  createdAt     DateTime @default(now())
  used          Boolean  @default(false)
  referralToken String?
}

model AdminImpersonationAudit {
  id                String   @id @default(cuid())
  adminEmail        String
  targetEmail       String
  reason            String
  originalUserEmail String?
  durationMinutes   Int?
  expiresAt         DateTime?
  startedAt         DateTime @default(now())
  endedAt           DateTime?
  startIp           String?
  startUserAgent    String?
  stopIp            String?
  stopUserAgent     String?

  @@index([adminEmail])
  @@index([targetEmail])
  @@index([startedAt])
}

model FinanceRecord {
  id        String   @id @default(cuid())
  type      String
  source    String
  category  String
  amount    Float
  status    String
  date      DateTime
  note      String?
  createdAt DateTime @default(now())
}

model CommissionRecord {
  id        String   @id @default(cuid())
  userId    String
  leadEmail String?
  type      String
  amount    Float
  status    String
  earnedAt  DateTime
  note      String?
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model JackpotPayout {
  id          String    @id @default(cuid())
  userId      String
  amount      Float
  drawingDate DateTime
  paid        Boolean   @default(false)
  paidDate    DateTime?
  createdAt   DateTime  @default(now())
  user        User      @relation(fields: [userId], references: [id])
}

model RateConfig {
  id                     String         @id @default(cuid())
  createdAt              DateTime       @default(now())
  updatedAt              DateTime       @updatedAt
  key                    String         @unique
  supplierSlug           String
  supplierName           String?
  planId                 String?
  nameId                 String?
  planName               String?
  tdsp                   String?
  tdspSlug               String?
  termMonths             Int?
  rateType               String?
  isGreen                Boolean?
  greenPct               Float?
  eflUrl                 String?
  tosUrl                 String?
  yracUrl                String?
  baseMonthlyFeeCents    Int?
  tduDeliveryCentsPerKwh Float?
  centsPerKwhJson        Json?
  billCreditsJson        Json?
  touWindowsJson         Json?
  otherFeesJson          Json?
  notes                  String?
  checksum               String?        @unique
  eflHash                String?
  fetchedAt              DateTime?
  validFrom              DateTime?
  validTo                DateTime?
  isActive               Boolean        @default(true)
  mappings               OfferRateMap[]
}

model OfferRateMap {
  id           String     @id @default(cuid())
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt
  offerId      String     @unique
  rateKey      String
  supplierSlug String
  planId       String?
  nameId       String?
  tdspSlug     String?
  eflUrl       String?
  lastSeenAt   DateTime   @default(now())
  rateConfigId String
  rateConfig   RateConfig @relation(fields: [rateConfigId], references: [id], onDelete: Cascade)

  /// Optional link to the persisted RatePlan template created from this offer's EFL.
  /// This makes WattBuy offer_id the authoritative fingerprint for attaching templates.
  ratePlanId String?
  ratePlan   RatePlan? @relation("OfferRateMap_RatePlan", fields: [ratePlanId], references: [id], onDelete: SetNull)

  @@index([supplierSlug, planId])
  @@index([supplierSlug, nameId])
  @@index([tdspSlug])
  @@index([ratePlanId])
}

/// Canonical offer_id -> RatePlan template link.
/// Unlike OfferRateMap, this does NOT require a RateConfig row, so EFL tooling can always upsert it.
model OfferIdRatePlanMap {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  offerId String @unique

  ratePlanId String?
  ratePlan   RatePlan? @relation(fields: [ratePlanId], references: [id], onDelete: SetNull)

  lastLinkedAt DateTime?
  linkedBy     String?
  notes        String?

  @@index([ratePlanId])
}

model MasterPlan {
  id             String      @id @default(uuid())
  source         PlanSource
  offerId        String?     @unique
  supplierName   String
  supplierPuctNo String?
  tdsp           TdspCode
  planName       String
  /// * Normalized keys from planmaster/keys.ts (Step 61)
  nameId         String
  planId         String
  termMonths     Int
  cancelFeeCents Int?
  productType    ProductType
  minUsageKwh    Int?
  hasBillCredit  Boolean     @default(false)
  eflUrl         String?
  tosUrl         String?
  yracUrl        String?
  /// * Raw provider payload (WattBuy offer, or other source)
  docs           Json
  /// * Parsed/normalized rate model from EFL (populated in Step 64)
  rateModel      Json?
  effectiveAt    DateTime    @default(now())
  expiresAt      DateTime?
  createdAt      DateTime    @default(now())
  updatedAt      DateTime    @updatedAt

  @@index([tdsp, termMonths])
  @@index([supplierName, planName])
  @@index([nameId])
  @@index([planId])
  @@index([effectiveAt])
  @@index([expiresAt])
}

model TdspRateSnapshot {
  id          String    @id @default(uuid())
  tdsp        TdspCode
  sourceUrl   String
  payload     Json
  effectiveAt DateTime?
  createdAt   DateTime  @default(now())

  @@index([tdsp, createdAt])
  @@index([effectiveAt])
}

enum QueueKind {
  EFL_PARSE
  PLAN_CALC_QUARANTINE
}

model EflParseReviewQueue {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Source of this record, e.g. "wattbuy_batch", "manual_upload".
  source String

  kind       QueueKind @default(EFL_PARSE)
  /// Cross-kind dedupe key used for schema-level de-duplication.
  /// Note: kept default/triggered for EFL_PARSE so existing writers don't need code changes.
  dedupeKey  String    @default("")
  /// Optional but helpful for PLAN_CALC_QUARANTINE items.
  ratePlanId String?

  /// Core EFL identity.
  eflPdfSha256       String  @unique
  repPuctCertificate String?
  eflVersionCode     String?

  /// Offer / plan metadata (WattBuy or other upstream).
  offerId    String?
  supplier   String?
  planName   String?
  eflUrl     String?
  tdspName   String?
  termMonths Int?

  /// Parsed payloads used by the validator/solver.
  rawText              String? @db.Text
  planRules            Json?
  rateStructure        Json?
  validation           Json?
  derivedForValidation Json?

  /// Final solver+validator outcome at time of queueing.
  finalStatus   String // e.g. "FAIL", "SKIP"
  queueReason   String? @db.Text
  solverApplied Json?

  /// Admin resolution metadata (null => OPEN).
  resolvedAt      DateTime?
  resolvedBy      String?
  resolutionNotes String?   @db.Text

  @@unique([kind, dedupeKey])
  @@index([finalStatus, createdAt])
}

model OfferAudit {
  id           String   @id @default(uuid())
  event        String
  planId       String
  supplierName String
  planName     String
  tdsp         String
  userKey      String?
  metadata     Json?
  createdAt    DateTime @default(now())

  @@index([planId])
  @@index([supplierName])
  @@index([tdsp])
  @@index([createdAt])
}

model FeatureFlag {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
  createdAt DateTime @default(now())
}

/// Raw WattBuy API response snapshots for audit + replay.
/// This is intentionally "append-only-ish": we store the raw payload + sha256 so we can
/// trace what WattBuy returned at a given time for a given request/house.
model WattBuyApiSnapshot {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  fetchedAt DateTime @default(now())

  /// Logical endpoint identifier (e.g. "OFFERS", "ELECTRICITY", "ELECTRICITY_INFO")
  endpoint String

  /// When the request can be tied to a stored address row (optional).
  houseAddressId String?

  /// When available from request or response.
  esiid   String?
  wattkey String?

  /// Optional stable key when houseAddressId is not available (e.g., zip or address slug)
  requestKey String?

  payloadJson   Json
  payloadSha256 String

  @@index([endpoint, houseAddressId])
  @@index([endpoint, esiid])
  @@index([endpoint, wattkey])
  @@index([payloadSha256])
}

model SupplierControl {
  id             String   @id @default(uuid())
  supplierName   String
  isBlocked      Boolean  @default(false)
  rolloutPercent Int?
  notes          String?
  updatedAt      DateTime @updatedAt
  createdAt      DateTime @default(now())

  @@index([supplierName])
}

/// OpenAI usage tracking for admin-visible cost and volume monitoring.
model OpenAIUsageEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())

  /// Logical module / subsystem (e.g. "current-plan", "rate-engine", "admin-tool")
  module    String @db.VarChar(64)
  /// Specific operation name (e.g. "bill-parse-v2", "efl-link-runner")
  operation String @db.VarChar(128)
  /// OpenAI model id (e.g. "gpt-4.1-mini")
  model     String @db.VarChar(64)

  inputTokens  Int
  outputTokens Int
  totalTokens  Int

  /// Approximate cost in USD for this call, stored as decimal
  costUsd Decimal @db.Decimal(10, 4)

  /// Optional OpenAI request id for correlation
  requestId String? @db.VarChar(128)
  /// Optional IntelliWatt userId when known
  userId    String? @db.VarChar(64)
  /// Optional houseId when call is tied to a home
  houseId   String? @db.VarChar(64)

  /// Arbitrary JSON metadata (e.g. { billParse: { houseId, esiid, fileId } })
  metadataJson Json?

  @@index([createdAt])
  @@index([module])
}

model HouseAddress {
  id                    String           @id @default(uuid())
  userId                String
  userEmail             String?
  houseId               String?
  /// Whether the customer is a renter (affects WattBuy offer eligibility set).
  /// IMPORTANT: this is an input to the offers dataset, not a dashboard "filter".
  isRenter              Boolean          @default(false)
  addressLine1          String
  addressLine2          String?
  addressCity           String
  addressState          String
  addressZip5           String
  addressZip4           String?
  addressCountry        String           @default("US")
  placeId               String?
  lat                   Float?
  lng                   Float?
  addressValidated      Boolean          @default(false)
  validationSource      ValidationSource @default(NONE)
  esiid                 String?          @unique
  tdspSlug              String?
  utilityName           String?
  utilityPhone          String?
  smartMeterConsent     Boolean          @default(false)
  smartMeterConsentDate DateTime?
  rawGoogleJson         Json?
  rawWattbuyJson        Json?
  createdAt             DateTime         @default(now())
  updatedAt             DateTime         @updatedAt
  isPrimary             Boolean          @default(false)
  archivedAt            DateTime?
  label                 String?          @db.VarChar(64)

  smtAuthorizations  SmtAuthorization[]
  entries            Entry[]
  manualUsageUploads ManualUsageUpload[]
  greenButtonUploads GreenButtonUpload[]

  @@index([placeId])
  @@index([addressState, addressZip5])
  @@index([esiid])
  @@index([userEmail])
  @@index([userId, isPrimary])
}

model GreenButtonUpload {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  house   HouseAddress @relation(fields: [houseId], references: [id])
  houseId String

  utilityName   String?
  accountNumber String?

  fileName      String
  fileType      String
  fileSizeBytes Int?

  storageKey String

  dateRangeStart  DateTime?
  dateRangeEnd    DateTime?
  intervalMinutes Int?

  parseStatus  String?
  parseMessage String?

  @@index([houseId])
  @@index([dateRangeStart, dateRangeEnd])
}

model RawSmtFile {
  id           BigInt    @id @default(autoincrement())
  filename     String
  size_bytes   Int
  sha256       String    @unique
  source       String?   @default("adhocusage")
  content_type String?   @default("application/octet-stream")
  storage_path String?
  content      Bytes?
  received_at  DateTime? @default(now())
  created_at   DateTime  @default(now())
  updated_at   DateTime  @updatedAt

  billingReads SmtBillingRead[]

  @@index([sha256])
  @@index([created_at])
  @@map("raw_smt_files")
}

model SmtInterval {
  id        String   @id @default(cuid())
  esiid     String
  meter     String
  ts        DateTime
  kwh       Decimal  @db.Decimal(10, 5)
  filled    Boolean  @default(false)
  source    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([esiid, meter, ts])
  @@index([esiid, meter, ts], map: "esiid_meter_ts_idx")
}

model SmtBillingRead {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  rawSmtFileId BigInt?
  rawSmtFile   RawSmtFile? @relation(fields: [rawSmtFileId], references: [id])

  esiid String
  meter String?

  tdspCode String?
  tdspName String?

  readStart DateTime?
  readEnd   DateTime?

  billDate DateTime?

  kwhTotal  Float?
  kwhBilled Float?

  source String?

  @@index([esiid, billDate])
  @@index([esiid, readStart])
  @@index([rawSmtFileId])
}

model SmtMeterInfo {
  id      String  @id @default(cuid())
  houseId String?
  esiid   String

  transId             String?
  meterNumber         String?
  utilityCompanyId    String?
  meterSerialNumber   String?
  utilityMeterId      String?
  kwhMeterMultiplier  Int?
  configuredChannels  String?
  manufacturerName    String?
  meterClass          String?
  intervalSetting     String?
  reverseFlowHandling String?
  dgChannel           String?
  disconnect          String?
  meterStatus         String?
  meterPhases         String?
  meterModel          String?

  testDate             String?
  installationDate     String?
  initialProvisionDate String?
  lastUpdatedRaw       String?

  communicationIndicator     String?
  instrumentRated            String?
  currentTransformersRatio   String?
  potentialTransformersRatio String?
  esiFirmwareVersion         String?
  hanProtocol                String?
  smartEnergyProfile         String?

  status       String  @default("pending")
  errorMessage String?
  rawPayload   Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([esiid, houseId])
  @@index([esiid])
}

model SmtAuthorization {
  id String @id @default(cuid())

  userId         String
  houseId        String
  houseAddressId String

  esiid       String
  meterNumber String?

  customerName String

  serviceAddressLine1 String
  serviceAddressLine2 String?
  serviceCity         String
  serviceState        String
  serviceZip          String

  tdspCode String
  tdspName String

  authorizationStartDate DateTime
  authorizationEndDate   DateTime

  allowIntervalUsage     Boolean
  allowHistoricalBilling Boolean
  allowSubscription      Boolean

  contactEmail String
  contactPhone String?

  smtRequestorId     String
  smtRequestorAuthId String

  smtAgreementId         String?   @db.VarChar(100)
  smtSubscriptionId      String?   @db.VarChar(100)
  smtStatus              String?   @db.VarChar(50)
  smtStatusMessage       String?   @db.Text
  smtBackfillRequestedAt DateTime?
  smtBackfillCompletedAt DateTime?
  smtLastSyncAt          DateTime?

  consentTextVersion      String?                    @db.VarChar(50)
  consentIp               String?                    @db.VarChar(64)
  consentUserAgent        String?                    @db.VarChar(255)
  archivedAt              DateTime?
  revokedReason           String?                    @db.VarChar(100)
  emailConfirmationStatus SmtEmailConfirmationStatus @default(PENDING)
  emailConfirmationAt     DateTime?

  user         User         @relation(fields: [userId], references: [id])
  houseAddress HouseAddress @relation(fields: [houseAddressId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([userId])
  @@index([houseId])
  @@index([houseAddressId])
  @@index([esiid])
  @@index([emailConfirmationStatus])
}

model PuctRep {
  id         String  @id @default(cuid())
  /// PUCT Retail Electric Provider certificate number, e.g. "10052"
  puctNumber String
  /// Legal company name as listed by PUCT, e.g. "JUST ENERGY TEXAS LP"
  legalName  String
  /// Doing-business-as / brand name (if present), e.g. "JUST ENERGY"
  dbaName    String?

  address1   String?
  address2   String?
  city       String?
  state      String?
  postalCode String?

  phone   String?
  website String?
  email   String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([puctNumber, legalName])
  @@index([puctNumber])
  @@index([legalName])
  @@index([dbaName])
}

/// RatePlan - normalized electricity plans (REP plans and utility tariffs)
model RatePlan {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  externalId   String?
  utilityId    String
  state        String
  supplier     String?
  supplierPUCT String?
  planName     String?

  /// Back-reference for OfferRateMap.ratePlan (WattBuy offer_id -> RatePlan template link)
  offerRateMaps       OfferRateMap[]       @relation("OfferRateMap_RatePlan")
  /// Back-reference for OfferIdRatePlanMap.ratePlan (canonical offerId -> RatePlan link)
  offerIdRatePlanMaps OfferIdRatePlanMap[]

  termMonths Int?
  rate500    Float?
  rate1000   Float?
  rate2000   Float?
  cancelFee  String?

  /// Modeled all-in average prices (¢/kWh) as computed by the EFL avg-price validator at persistence time.
  /// These are stored as evidence that our parsed RateStructure reproduces the EFL disclosure table.
  modeledRate500               Float?
  modeledRate1000              Float?
  modeledRate2000              Float?
  /// Full validator snapshot (includes expected vs modeled points, assumptionsUsed, snippet, etc.)
  modeledEflAvgPriceValidation Json?
  modeledComputedAt            DateTime?

  // Source documents for this plan (EFL, TOS, YRAC)
  eflUrl  String?
  tosUrl  String?
  yracUrl String?

  // EFL Fact Card identity + validation (AI-backed PlanRules extractor)
  repPuctCertificate      String?
  eflVersionCode          String?
  eflPdfSha256            String? @unique
  // Canonical source URL for the EFL used for this plan version
  eflSourceUrl            String?
  // Whether the AI-derived PlanRules for this EFL require manual review
  eflRequiresManualReview Boolean @default(false)
  // Structured validation issues from PlanRulesValidationResult
  eflValidationIssues     Json?
  // Normalized pricing structure derived from PlanRules (see lib/efl/planEngine.ts)
  rateStructure           Json?

  // IntelliWatt plan-calc persistence (derived from template; stable for auditing)
  planCalcVersion    Int       @default(1)
  planCalcStatus     String? // "COMPUTABLE" | "NOT_COMPUTABLE" | "UNKNOWN"
  planCalcReasonCode String? // e.g. "FIXED_RATE_OK", "UNSUPPORTED_RATE_STRUCTURE", "MISSING_TEMPLATE"
  requiredBucketKeys String[]  @default([])
  supportedFeatures  Json?
  planCalcDerivedAt  DateTime?

  isUtilityTariff Boolean   @default(false)
  tariffStructure Json?
  customerCharge  Float?
  minimumBill     Float?
  effectiveStart  DateTime?
  effectiveEnd    DateTime?
  sourceRateUrl   String?
  sourceParentUrl String?

  lastSeenAt DateTime @default(now())

  @@unique([utilityId, state, supplier, planName, termMonths, isUtilityTariff])
  @@index([utilityId, state, termMonths])
}

/// Materialized, home-scoped plan estimates (single source of truth for customer/admin UI).
/// Keying is engine-pure so every call site reads the same row for the same inputs.
model PlanEstimateMaterialized {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Home identity (HouseAddress.id)
  houseAddressId String
  /// Template identity (RatePlan.id)
  ratePlanId     String

  /// Canonical engine input fingerprint (includes engine version, TDSP, usage digest, rateStructure hash, estimateMode, etc.)
  inputsSha256 String
  monthsCount  Int    @default(12)

  /// Engine output status (e.g. "OK", "APPROXIMATE", "MISSING_USAGE", "MISSING_TEMPLATE", "NOT_COMPUTABLE", "NOT_IMPLEMENTED")
  status String
  /// Optional human/debug reason (stable codes preferred)
  reason String?

  annualCostDollars    Float?
  monthlyCostDollars   Float?
  effectiveCentsPerKwh Float?

  confidence       String? // e.g. "LOW" | "MEDIUM"
  componentsV2     Json?
  tdspRatesApplied Json?

  computedAt DateTime?
  /// Refresh cadence (default policy: 30 days, or earlier when inputs change which yields a new inputsSha256 anyway)
  expiresAt  DateTime?

  @@unique([houseAddressId, ratePlanId, inputsSha256])
  @@index([houseAddressId])
  @@index([ratePlanId])
  @@index([houseAddressId, ratePlanId])
  @@index([computedAt])
}

/// IntelliWattBot - per-page guidance messages shown across customer dashboard pages.
model IntelliwattBotPageMessage {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  /// Stable key representing a dashboard page (e.g. "dashboard_plans").
  pageKey String @unique

  /// Message shown in the bot speech bubble.
  message String @db.Text

  enabled Boolean @default(true)

  notes String? @db.Text

  @@index([enabled])
}

/// ERCOT Ingest - tracks ingestion history
model ErcotIngest {
  id          String   @id @default(cuid())
  createdAt   DateTime @default(now())
  status      String // "ok" | "skipped" | "error"
  note        String? // freeform note (e.g., "daily", "manual test")
  fileUrl     String?
  fileSha256  String?  @unique
  tdsp        String? // oncor|centerpoint|aep_north|aep_central|tnmp|unknown
  rowCount    Int?
  headers     Json? // snapshot of response headers for drift
  error       String? // short error
  errorDetail String? // long stack
}

/// ERCOT ESIID Index - stores normalized ESIID data from ERCOT extracts
model ErcotEsiidIndex {
  id              BigInt   @id @default(autoincrement())
  esiid           String   @unique @db.VarChar(22)
  tdspCode        String?  @db.VarChar(16)
  serviceAddress1 String?
  serviceCity     String?  @db.VarChar(64)
  serviceState    String?  @db.Char(2)
  serviceZip      String?  @db.VarChar(10)
  status          String?  @db.VarChar(16)
  premiseType     String?  @db.VarChar(32)
  postedAtUtc     DateTime @db.Timestamptz(6)
  normLine1       String?
  normCity        String?  @db.VarChar(64)
  normZip         String?  @db.VarChar(10)

  @@index([normZip])
  @@index([normLine1(ops: raw("gin_trgm_ops"))], map: "ercot_esiid_index_normline1_trgm", type: Gin)
}

enum PlanSource {
  wattbuy
  manual
  tdsp_feed
}

enum ValidationSource {
  NONE
  GOOGLE
  USER
  OTHER
}

enum TdspCode {
  ONCOR
  CENTERPOINT
  AEP_NORTH
  AEP_CENTRAL
  TNMP
}

enum TdspTariffIngestRunStatus {
  SUCCESS
  PARTIAL
  ERROR
}

enum ProductType {
  fixed
  variable
  indexed
  tou
}

/// TDSP / utility master table (normalized by TdspCode).
model TdspUtility {
  id               String   @id @default(cuid())
  code             TdspCode @unique
  name             String
  shortName        String?
  serviceTerritory String?
  websiteUrl       String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  tariffs TdspTariffVersion[]
}

/// Versioned TDSP tariff documents, with effective date ranges and source metadata.
model TdspTariffVersion {
  id              String      @id @default(cuid())
  tdspId          String
  tdsp            TdspUtility @relation(fields: [tdspId], references: [id])
  tariffCode      String?
  tariffName      String?
  effectiveStart  DateTime
  effectiveEnd    DateTime?
  sourceUrl       String?
  sourceDocSha256 String?     @unique
  planSource      PlanSource
  notes           String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  components TdspTariffComponent[]

  @@index([tdspId, effectiveStart, effectiveEnd])
}

/// Individual TDSP tariff components (customer charge, delivery ¢/kWh, riders, etc.).
model TdspTariffComponent {
  id              String            @id @default(cuid())
  tariffVersionId String
  tariffVersion   TdspTariffVersion @relation(fields: [tariffVersionId], references: [id])
  chargeName      String
  chargeType      String
  unit            String
  /// Canonical rate stored in "cents" for PER_MONTH / PER_KWH, or raw units for other charge types.
  rate            Decimal           @db.Decimal(10, 4)
  minKwh          Int?
  maxKwh          Int?
  notes           String?
  rawSourceJson   Json?
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt

  @@index([tariffVersionId, chargeType, unit])
}

model TdspTariffIngestRun {
  id         String                    @id @default(cuid())
  createdAt  DateTime                  @default(now())
  startedAt  DateTime
  finishedAt DateTime?
  status     TdspTariffIngestRunStatus
  trigger    String // "VERCEL_CRON" | "ADMIN_API" | "DROPLET_CRON" | etc.
  sourceKind String // e.g. "PUCT_RATE_REPORT_PDF"

  processedTdspCount  Int @default(0)
  createdVersionCount Int @default(0)
  noopVersionCount    Int @default(0)
  skippedTdspCount    Int @default(0)
  errorTdspCount      Int @default(0)

  changesJson Json? // array of {tdspCode, action, effectiveStartISO, versionId, sha256}
  errorsJson  Json? // array of {tdspCode, message, stack?, hint?}
  logs        String? // optional compact logs (keep short)

  @@index([createdAt])
}
