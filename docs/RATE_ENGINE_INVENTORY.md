# Rate Engine Inventory (v1) — IntelliWatt

**Purpose:** single source of truth for what the current (v1) plan cost engine can and cannot compute, how computability is decided, and what coverage looks like in the production database.

**Key entrypoints:**
- Engine math (v1): `lib/plan-engine/calculatePlanCostForUsage.ts`
- Computability + bucket requirements: `lib/plan-engine/planComputability.ts`, `lib/plan-engine/requiredBucketsForPlan.ts`
- Dashboard gating + quarantine: `app/api/dashboard/plans/route.ts`
- DB fields: `RatePlan.planCalcStatus`, `RatePlan.planCalcReasonCode`, `RatePlan.requiredBucketKeys` (`prisma/schema.prisma`)

---

## What’s supported today (v1)

### Fixed-rate REP energy (single-rate, single-tier)
- **Supported**: a single fixed REP energy rate in **¢/kWh** if it can be extracted unambiguously.
- Source: `extractFixedRepEnergyCentsPerKwh(rateStructure)` (fail-closed if ambiguous).

### Base monthly charge handling
- **Supported (best-effort)**: REP fixed monthly charge if it can be extracted as a single value.
- Source: `extractRepFixedMonthlyChargeDollars(rateStructure)` (defaults to `$0` if missing).

### TDSP delivery passthrough (delivery + customer)
- **Supported**: TDSP delivery **¢/kWh** + monthly customer charge **$/mo**, sourced from the TDSP module (`getTdspDeliveryRates`), not from the EFL template.
- Applied by `calculatePlanCostForUsage()` as:
  - annual delivery = \(annualKwh \times tdspDeliveryCents / 100\)
  - annual customer charge = \(12 \times tdspCustomerCharge\)

### Required bucket keys (usage inputs)
**Always required** (v1):  
- `kwh.m.all.total`

Notes:
- v1 engine consumes annual kWh derived from monthly totals of `kwh.m.all.total` (usage module DB).
- The engine is structured to expand required buckets later for TOU/weekend/night splits.

### What is NOT applied in v1 (even if parsed)
- **Bill credits**: may be detected as “present” (for feature flags), but are **not** applied in v1 bill math.
- **ETF**: may be extracted/displayed in UI, but does **not** affect computed costs.
- **Taxes / misc fees**: not applied.

---

## What is explicitly NOT supported today (v1)

These are treated as **NOT_COMPUTABLE** (fail-closed) when detected or when no fixed-rate energy can be safely extracted:

### TOU / schedules (free nights / free weekends / time-of-use)
- Status: **NOT supported**
- Reason code: `UNSUPPORTED_RATE_STRUCTURE`
- Notes: `inferSupportedFeaturesFromTemplate()` conservatively sets TOU support to `false` and records detection notes.

### Variable / indexed / market pricing
- Status: **NOT supported**
- Reason code: `UNSUPPORTED_RATE_STRUCTURE` (v1)

### Tiered energy rates (multi-tier)
- Status: **NOT supported**
- Reason code: `UNSUPPORTED_RATE_STRUCTURE` (v1)

### Solar buyback / export compensation
- Status: **NOT supported** (explicitly)

---

## How “computable” is decided

### 1) Template presence (RatePlan mapping + rateStructure)
- If an offer is **not** mapped to a `RatePlan` (`OfferIdRatePlanMap.ratePlanId`), computability is treated as missing.
- If `rateStructure` is missing / JSON-null-like, the template is treated as missing.

Outcome:
- `planCalcStatus = UNKNOWN`
- `planCalcReasonCode = MISSING_TEMPLATE`

### 2) Requirements derivation (persisted on `RatePlan`)
Derivation function:
- `derivePlanCalcRequirementsFromTemplate({ rateStructure })`

Current behavior:
- If a single fixed REP energy rate is extractable → `COMPUTABLE` / `FIXED_RATE_OK`
- Otherwise → `NOT_COMPUTABLE` / `UNSUPPORTED_RATE_STRUCTURE`
- `requiredBucketKeys` is currently set to `["kwh.m.all.total"]` for both paths (even when NOT_COMPUTABLE) for auditing.

### 3) Dashboard availability mapping

Customer-facing semantics (important):
- `AVAILABLE`: mapped **and** `planCalcStatus === "COMPUTABLE"`
- `QUEUED`: mapped but **not computable yet** (or unmapped but has an EFL URL)
- `UNAVAILABLE`: unmapped and no EFL URL

This mapping lives in `/api/dashboard/plans` and is what controls:
- the “Best plans by IntelliWatt all-in” section
- the “Templates: available” filter

### 4) Quarantine behavior (best-effort)
When an offer has a template but is NOT_COMPUTABLE, `/api/dashboard/plans` best-effort upserts an open queue item:
- `EflParseReviewQueue.kind = PLAN_CALC_QUARANTINE`
- `EflParseReviewQueue.dedupeKey = offerId`

This is how we track “queued for calculation review” without breaking the customer endpoint.

---

## Impact summary from PROD (current snapshot)

Generated by:
- `npm run admin:rateplan:report`
- `npm run admin:rateplan:missing-buckets`
- `npm run admin:rateengine:inventory`

### RatePlan template inventory
- **Total `RatePlan` rows**: 232
- **COMPUTABLE**: 222
- **NOT_COMPUTABLE**: 2
- **UNKNOWN (missing template)**: 8
- **rateStructure present**: 224
- **rateStructure missing**: 8
- **requiredBucketKeys empty**: 8

Counts by `planCalcReasonCode`:
- `FIXED_RATE_OK`: 222
- `MISSING_TEMPLATE`: 8
- `UNSUPPORTED_RATE_STRUCTURE`: 2

### Offer coverage (what dashboard actually uses)
Mapped offers by template status:
- **COMPUTABLE**: 97 mapped offers
- **NOT_COMPUTABLE**: 4 mapped offers

Top NOT_COMPUTABLE templates by mapped-offer count:
1) `cmj8deqfq000fl104hfym7ngm` — REP `10098` — `Champ Saver-1` — `VARIABLE-EFL-20230918` — `UNSUPPORTED_RATE_STRUCTURE` — 2 offers
2) `cmj7y4jtd000cl504sy0h0imz` — REP `10098` — `Free Weekends-24` — `TOU-EFL-20230918` — `UNSUPPORTED_RATE_STRUCTURE` — 2 offers

---

## Next gaps ranked (do NOT implement yet)

### 1) v2 TOU bucket model (nights/weekends/free periods)
- **What data needed**: TOU schedule + periods in `rateStructure` (e.g. time windows, weekday/weekend rules).
- **Where it lives**: likely `rateStructure.timeOfUseTiers` or equivalent parsed schedule fields.
- **What buckets needed**:
  - at minimum: `kwh.m.all.2000-0700`, `kwh.m.all.0700-2000`
  - for weekend-based plans: weekday/weekend splits (`kwh.m.weekday.*`, `kwh.m.weekend.*`)
- **How to test**:
  - pick a known “Free Weekends” template (REP 10098) and confirm modeled totals match expected EFL anchor points for a synthetic usage profile.

### 2) Variable / indexed strategy
- **What data needed**: index source, adder, caps, update cadence (monthly?), and historical series or assumptions.
- **Where it lives**: `rateStructure` variable/index fields (if present) or currently missing in templates.
- **What buckets needed**: still `kwh.m.all.total` (but pricing depends on time-series, not just buckets).
- **How to test**:
  - define a “frozen index” assumption for backtesting and compare to EFL examples (if present).

### 3) Tiered energy strategy
- **What data needed**: tier boundaries + tier prices per kWh, and whether base fee varies by tier.
- **Where it lives**: `rateStructure.tiers` / `rateStructure.usageTiers` (detected today as unsupported).
- **What buckets needed**: total kWh is sufficient for many tiered plans, but tiers need monthly kWh (we already have month buckets).
- **How to test**:
  - validate against EFL “Average Price” anchors by reconstructing 500/1000/2000 kWh bills.


